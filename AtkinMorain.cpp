// uses NTL
//   http://www.shoup.net/ntl
// reference:
//   R. Crandall and C. Pomerance
//    "Prime Numbers: A Computational Perspective"
//     2nd edition, Algorithm 7.5.9, 7.6.3

#include<NTL/ZZX.h>
#include<NTL/ZZ_pXFactoring.h>
#include "ECPP.h"
using namespace NTL;

#define AM_NMIN (1<<30) // > ECPP_TRYDIV_MAX

static short discr[] =
// fundamental discriminants of imaginary quadratic field
// generated by table1.cpp
{   // class number 1
    -3, -4, -7, -8, -11, -19, -43, -67, -163,
    // class number 2
    -15, -20, -24, -35, -40, -51, -52, -88, -91, -115,
    -123, -148, -187, -232, -235, -267, -403, -427,
    // class number 3
    -23, -31, -59, -83, -107, -139, -211, -283, -307, -331,
    -379, -499, -547, -643, -883, -907,
    // class number 4
    -39, -55, -56, -68, -84, -120, -132, -136, -155, -168,
    -184, -195, -203, -219, -228, -259, -280, -291, -292, -312,
    -323, -328, -340, -355, -372, -388, -408, -435, -483, -520,
    -532, -555, -568, -595, -627, -667, -708, -715, -723, -760,
    -763, -772, -795, -955, -1003, -1012, -1027, -1227, -1243, -1387, 
    -1411, -1435, -1507, -1555,
    // class number 5
    -47, -79, -103, -127, -131, -179, -227, -347, -443, -523, 
    -571, -619, -683, -691, -739, -787, -947, -1051, -1123, -1723,
    -1747, -1867, -2203, -2347, -2683,
    // class number 6
    -87, -104, -116, -152, -212, -244, -247, -339, -411, -424, 
    -436, -451, -472, -515, -628, -707, -771, -808, -835, -843, 
    -856, -1048, -1059, -1099, -1108, -1147, -1192, -1203, -1219, -1267,
    -1315, -1347, -1363, -1432, -1563, -1588, -1603, -1843, -1915, -1963,
    -2227, -2283, -2443, -2515, -2563, -2787, -2923, -3235, -3427, -3523,
    -3763,
    // class number 7
    -71, -151, -223, -251, -463, -467, -487, -587, -811, -827,
    -859, -1163, -1171, -1483, -1523, -1627, -1787, -1987, -2011, -2083,
    -2179, -2251, -2467, -2707, -3019, -3067, -3187, -3907, -4603, -5107, 
    -5923,
    // class number 8
    -95, -111, -164, -183, -248, -260, -264, -276, -295, -299,
    -308, -371, -376, -395, -420, -452, -456, -548, -552, -564,
    -579, -580, -583, -616, -632, -651, -660, -712, -820, -840,
    -852, -868, -904, -915, -939, -952, -979, -987, -995, -1032,
    -1043, -1060, -1092, -1128, -1131, -1155, -1195, -1204, -1240, -1252,
    -1288, -1299, -1320, -1339, -1348, -1380, -1428, -1443, -1528, -1540,
    -1635, -1651, -1659, -1672, -1731, -1752, -1768, -1771, -1780, -1795,
    -1803, -1828, -1848, -1864, -1912, -1939, -1947, -1992, -1995, -2020,
    -2035, -2059, -2067, -2139, -2163, -2212, -2248, -2307, -2308, -2323,
    -2392, -2395, -2419, -2451, -2587, -2611, -2632, -2667, -2715, -2755,
    -2788, -2827, -2947, -2968, -2995, -3003, -3172, -3243, -3315, -3355,
    -3403, -3448, -3507, -3595, -3787, -3883, -3963, -4123, -4195, -4267,
    -4323, -4387, -4747, -4843, -4867, -5083, -5467, -5587, -5707, -5947,
    -6307,
};

#define NumDiscr (sizeof(discr)/sizeof(short))

long AtkinMorain_(ECPPCert& c, const ZZ& n, long verbose)
// primality proving by Atkin-Morain method
// return 1 if n is proved prime
// return 0 if n is proved composite
// return -1 if not proved
// if n is prime, set c = certificate of proof
// if verbose!=0, print recursion steps
// assume n is probable prime (by Miller-Rabin test)
{
    long i,j,k,d,W,p;
    if(verbose)
        std::cout << "n=" << n << std::endl;
    if(n < AM_NMIN) {
        conv(p,n);
        if(!IsPrime(p)) return 0;
        c.SetLength(1);
        c[0].n = n;
        return 1;
    }
    ZZ u,v,n1,m,q,t,q1;
    ZZX f;
    ZZ_p::init(n);
    ZZ_p a,b,g,g2,g3;
    EC_p P,Q,R;
    ZZ_pX h;
    add(n1,n,1);
    SqrRoot(q1,n); LeftShift(t,q1,2);
    SqrRoot(t,t);
    q1+=t; q1++;// q1 = ([n^{1/4}] + 1)^2
    for(;;) {
        random(g);
        if(Jacobi(rep(g), n)>=0) continue;
        if(n%3 != 1) break;
        sub(t,n,1); t/=3;
        power(g2,g,t);
        if(!IsOne(g2)) break;
    }
    sqr(g2,g);
    mul(g3,g2,g);
    for(i=0; i<NumDiscr; i++) {
        d = discr[i];
        conv(t,d);
        if(cornacchia(u,v,t,n)) continue;
        if(d==-3) {
            W=6;
            v*=3;
            conv(b,-1);
        }
        else if(d==-4) {
            W=4;
            v<<=1;
            conv(a,-1);
            clear(b);
        }
        else {
            W=2;
            ClassPoly(f,d);
            conv(h,f);
            FindRoot(b,h);
            sub(a,b,1728);
            b/=a;
            mul(a,b,-3);
            b*=2;
        }
        for(j=0; j<W; j++) {
            if(j==0)      add(m,n1,u);
            else if(j==1) sub(m,n1,u);
            else if(d==-3) {
                if(j==2) {
                    add(t,u,v); t>>=1;
                    add(m,n1,t);
                }
                else if(j==3) {
                    sub(t,u,v); t>>=1;
                    add(m,n1,t);
                }
                else if(j==4) {
                    add(t,u,v); t>>=1;
                    sub(m,n1,t);
                }
                else {
                    sub(t,u,v); t>>=1;
                    sub(m,n1,t);
                }
            }
            else if(d==-4) {
                if(j==2) add(m,n1,v);
                else     sub(m,n1,v);
            }
            if(ProbPrimeFactor(q,m,q1)) continue;
            div(t,m,q);
            EC_p::init(a,b);
            for(k=0; k<W; k++) {
                for(;;) {
                    random(P);
                    mul(Q,P,t);
                    mul(R,Q,q);
                    if(!IsZero(R)) break;
                    if(!IsZero(Q)) goto a;
                }
                if(d==-3) EC_p::b() *= g;
                else if(d==-4) EC_p::a() *= g;
                else {
                    EC_p::a() *= g2;
                    EC_p::b() *= g3;
                }
            }
            return 0;
        a:  ;
            if(!z_coprime(Q)) return 0;
            else {
                EC_pPush push;
                k = AtkinMorain(c,q,verbose);
            }
            if(k<=0) continue;
            k = c.length();
            c.SetLength(k+1);
            set(c[k], P, m);
            return 1;
        }
    }
    return -1;// run out of discriminant
}

long AtkinMorain(ECPPCert& c, const ZZ& n, long verbose)
// perform Miller-Rabin test before proving primality
{
    if(!ProbPrime(n)) return 0;
    c.SetLength(0);
    return AtkinMorain_(c,n,verbose);
}

long AtkinMorain(const ZZ& n, long verbose)
// do not output certificate
{
    ECPPCert c;
    return AtkinMorain(c,n,verbose);
}